<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <h2>Search Problems</h2>
    <p>A <strong>Search Problem</strong> consists of:</p>
    <ul>
      <li><strong>State space:</strong> all possible states</li>
      <li><strong>Successor Function:</strong> What is the next state after taking an action in a given state</li>
      <li><strong>Start State:</strong>What is the initial state</li>
      <li><strong>Goal Test:</strong> What is the machine trying to achieve</li>
    </ul>
    <p>We would then need a solution to solve the search problem. A <strong>Solution</strong> is a sequence of actions starting from the Start State to the Goal State.<br>In Search Problems, we want to abstract away unnecessary details to capture just enough information.</p>
    <h3>State Space</h3>
    <p>A <strong>State Space</strong> consists of a <strong>World State</strong>, every single detail of the environment, and a <strong>Search State</strong>, only details needed for planning.</p>
    <h3>State Space Graphs</h3>
    <p>This is a mathematical way of representing search problems. The nodes are the possible states and the arcs/edges represent the successors.<br></p>
    <p>A <strong>Search Tree</strong> is a tree where the root node is the start state, the edges are the actions, and the children are successors of the parent given the edge action.<br>Every search algorithm should be:</p>
    <ul>
      <li><strong>Complete:</strong> Guaranteed to find a solution if one exists</li>
      <li><strong>Optimal:</strong> Guaranteed to find the least solution</li>
    </ul>
    <p>There is also the time and space complexity that comes with every algorithm.</p>
    <h4>Depth-First Search</h4>
    <p>This strategy is to explore the the deepest nodes first. It uses LIFO stack, which means we keep pushing all child of the node, pop the top node and iteratively run the algorithm. Terminates when the stack is empty.</p>
    <p><code>def dfs:<br><span style="white-space: pre-wrap">&#x20;&#x20;</span>place root node on stack<br><span style="white-space: pre-wrap">&#x20;&#x20;</span>while stack is not empty<br><span style="white-space: pre-wrap">&#x20;&#x20;&#x20;&#x20;</span>pop the stack<br><span style="white-space: pre-wrap">&#x20;&#x20;&#x20;&#x20;</span>ignore if node is visited<br><span style="white-space: pre-wrap">&#x20;&#x20;&#x20;&#x20;</span>append node to result and set as visited<br><span style="white-space: pre-wrap">&#x20;&#x20;&#x20;&#x20;</span>for every children of node:<br><span style="white-space: pre-wrap">&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;</span>if the node is not visited<br><span style="white-space: pre-wrap">&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;</span>set node as visited<br><span style="white-space: pre-wrap">&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;</span>place node in stack<br><span style="white-space: pre-wrap">&#x20;&#x20;</span>return result<br></code></p>
    <h4>Breadth-First Search</h4>
    <p>Expand across by breadth instead of depth. This is implemented using a FIFO queue. we start with the root node, place all children in a queue, dequeue the first children, repeat.</p>
    <p><code>def bfs:<br><span style="white-space: pre-wrap">&#x20;&#x20;</span>place root node in queue<br><span style="white-space: pre-wrap">&#x20;&#x20;</span>while queue is not empty<br><span style="white-space: pre-wrap">&#x20;&#x20;&#x20;&#x20;</span>dequeue a node<br><span style="white-space: pre-wrap">&#x20;&#x20;&#x20;&#x20;</span>ignore if node is visited<br><span style="white-space: pre-wrap">&#x20;&#x20;&#x20;&#x20;</span>append node to result and set as visited<br><span style="white-space: pre-wrap">&#x20;&#x20;&#x20;&#x20;</span>for every children of node:<br><span style="white-space: pre-wrap">&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;</span>if the node is not visited<br><span style="white-space: pre-wrap">&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;</span>set node as visited<br><span style="white-space: pre-wrap">&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;&#x20;</span>place node in queue<br><span style="white-space: pre-wrap">&#x20;&#x20;</span>return result<br></code></p>
    <h3>Uniform Cost Search</h3>
    <p>Expands the cheapest node first using a priority queue. This is similar to Breadth-First Search where each depth is the cost of the node. This means we can represent the tree with cost contours, or layer with path of equal cost.</p>
  </body>
</html>
